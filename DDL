--Scripts

-- Criado tabela de Tipo de Produto
-- Com ID_TP_PROD sendo number e sempre identity, não aceita null, e é criado automaticamente uma sequence que controla o autoincremento.
-- A tabela possui um Index também IX_TIPO_PRODUTO para o campo ID_TP_PROD que é Primary Key
--Todos Obejtos criados no esquema do usuário SYSTEM e tablespace SYSTEM;
CREATE TABLE "SYSTEM"."TIPO_PRODUTO" (
    "ID_TP_PROD" NUMBER GENERATED ALWAYS AS IDENTITY NOT NULL ENABLE,
    "NM_TIPO" VARCHAR2(50) NOT NULL,
    "DT_CAD" TIMESTAMP DEFAULT SYSDATE NOT NULL ENABLE,
    CONSTRAINT "IX_TIPO_PRODUTO" PRIMARY KEY ("ID_TP_PROD")
) TABLESPACE "SYSTEM";

-- Script gerado e criado objeto sequence pelo Banco Oracle
CREATE SEQUENCE ISEQ$$_73568 INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20

-- script INDEX da tabela Produto 
CREATE UNIQUE INDEX "SYSTEM"."PRODUTO_ID_PROD_PK" ON "SYSTEM"."PRODUTO" ("ID_PROD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;

-- inderindo Dados na tabela, não sendo necessário passar valor para ID_TP_PROD, que é gerado automaticamente
insert into TIPO_PRODUTO (nm_tipo) values ('ALIMENTICIO');
insert into TIPO_PRODUTO (nm_tipo) values ('LIMPEZA');
insert into TIPO_PRODUTO (nm_tipo) values ('UTENCILIOS DE COZINHA');
select * from TIPO_PRODUTO;

-- Criado tabela PRODUTO, com ID_PROD sendo sempre Identity, Not NUll e Index por esse campo.
-- DT_CAD_PROD com DEFAULT SYSDATE
CREATE TABLE "SYSTEM"."PRODUTO" (
    "ID_PROD" NUMBER GENERATED ALWAYS AS IDENTITY NOT NULL ENABLE, 
	"NM_PROD" VARCHAR2(100 BYTE), 
	"TP_PROD" NUMBER(*,0) NOT NULL ENABLE, 
	"DT_CAD_PROD" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	 CONSTRAINT "PRODUTO_ID_PROD_PK" PRIMARY KEY ("ID_PROD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
  
  -- Sequence criada pelo ORACLE ao criar e referenciar o campo ID_PROD como IDENTITY
  CREATE SEQUENCE ISEQ$$_73561 INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20
  
  -- Index Criado para a tabela PRODUTO campo ID_PROD
  CREATE UNIQUE INDEX "SYSTEM"."IX_TIPO_PRODUTO" ON "SYSTEM"."TIPO_PRODUTO" ("ID_TP_PROD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
  
  --Criado um Inndex UNIQUE também para o campo NM_PROD, impedindo o cadastro de produtos iguais
  --Se tirado o parametro UNIQUE, ele se torna não-exclusivo, podendo receber o cadastros iguais
  CREATE UNIQUE INDEX IX_PRODUTO_NM_PROD ON PRODUTO (NM_PROD ASC);

--Alterando o campo NM_PROD da tabela PRODUTO para não aceitar valores null
ALTER TABLE PRODUTO MODIFY (NM_PROD NOT NULL);

-- Adicionando um FK na tabela PRODUTO referenciando ao campo ID_TP_PROD da tabela TIPO_PRODUTO
ALTER TABLE PRODUTO ADD CONSTRAINT FK_PRODUTO_TP_PROD FOREIGN KEY (TP_PROD)
REFERENCES TIPO_PRODUTO (ID_TP_PROD) ENABLE;

-- Posso criar uma tabela com GENERATED BY DEFAULT AS IDENTITY
-- É gerada e controlado automaticamente via a sequence o id do campo
-- E por ser BY DEFAULT, a tabela aceita inserir manualmente um valor para a chave também
-- Não aceita NULL para o campo
CREATE TABLE TABELA_EXEMPLO (
  id          NUMBER GENERATED BY DEFAULT AS IDENTITY,
  descricao   VARCHAR2(30)
);

--Exemplos de Insert
insert into TABELA_EXEMPLO (descricao) values ('Cadastro 01'); -- Registro inserido com ID 1
insert into TABELA_EXEMPLO (id, descricao) values (2, 'Cadastro 02'); -- Registro inserido  com ID 2 que foi passado manualmente

-- Posso criar uma tabela com NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY
-- É gerada e controlado automaticamente via a sequence o id do campo
-- Aceita inserir um registro e ser informado um vaor para a chave de itendificação
-- Aceita inserir um registro não passando a chave
CREATE TABLE TABELA_EXEMPLO2 (
  id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  descricao   VARCHAR2(30)
);

--Exemplos de Insert
insert into TABELA_EXEMPLO2 (descricao) values ('Cadastro 01'); -- Registro inserido com ID 1
insert into TABELA_EXEMPLO2 (id, descricao) values (2, 'Cadastro 01'); -- Registro inserido com ID 2, que foi passado manualmente
insert into TABELA_EXEMPLO2 (id, descricao) values (NULL, 'Cadastro 03'); -- Registro inserido com ID 3, mesmo informaado null, foi gerado o ID da proxima sequencia.

--Criado uma Procedure todos parâmetros IN por default quando não é especificado
   CREATE OR REPLACE PROCEDURE proc_add_produto (p_nm_prod VARCHAR2, p_tp_prod NUMBER) AS
   BEGIN
        INSERT INTO PRODUTO (nm_prod, tp_prod) VALUES (p_nm_prod, p_tp_prod);
   END;
   
   --Executado procedure e consultado a tabela
   EXECUTE proc_add_produto('MILHO DE PIPOCA', 1);
   SELECT * FROM PRODUTO;
   
   -- Um segundo exemplo de procedure de cadastro de Produto, com um retorno do pakage dbms_output, listando no display o Resultado
   CREATE OR REPLACE PROCEDURE proc_add_produto_com_retorno (p_nm_prod VARCHAR2, p_tp_prod NUMBER) AS
   total_produtos NUMBER;
   BEGIN
        INSERT INTO PRODUTO (nm_prod, tp_prod) VALUES (p_nm_prod, p_tp_prod);
        total_produtos := func_get_total_produtos;
        dbms_output.put_line('Total de Produtos Cadastrados é : ' || total_produtos);
   END;
   
   EXECUTE proc_add_produto_com_retorno ('TRIGO', 1);
   SELECT * FROM PRODUTO;
   
   -- Procedure para Atualizar Descrição nome Produto
   CREATE OR REPLACE PROCEDURE proc_update_produto (p_id_prod NUMBER, p_nm_prod VARCHAR2) AS
   BEGIN
        UPDATE PRODUTO SET nm_prod = p_nm_prod
        WHERE
        id_prod = p_id_prod;
   END;
   
   -- Executando Procedure de Atualização
   EXECUTE proc_update_produto (25, 'MILHO PIPOCA');
   SELECT * FROM PRODUTO;
   
   -- Procedure para Excluir Cadastro de Produto
  CREATE OR REPLACE PROCEDURE proc_delete_produto (p_id_prod NUMBER) AS
   BEGIN
        DELETE FROM PRODUTO WHERE id_prod = p_id_prod;
   END;
   
   --Executando Procedure
   EXECUTE proc_delete_produto (25);
   SELECT * FROM PRODUTO; 

-- Criado uma procedure que retorno um parametro OUT
create or replace PROCEDURE proc_consulta_total_Produtos (p_out_tot_prod OUT NUMBER) AS
   BEGIN
        SELECT COUNT(ID_PROD) INTO p_out_tot_prod FROM PRODUTO;
        dbms_output.put_line('Total de Produtos Cadastrados é : ' || p_out_tot_prod);
   END;

--Executando Procedure dentro de um bloco para testar parâmetro OUT
-- É atribuido o valor 5 só para teste, porém é retornado o valor total de produtos executado pela proc_consulta_total_Produtos
DECLARE retorno NUMBER := 5;
   BEGIN
        proc_consulta_total_Produtos(retorno);
        dbms_output.put_line('Retorno é igual : ' || retorno);
   END;
   
   --Criado Função para Retornar o Total de Produtos
   create or replace FUNCTION func_get_total_produtos
   RETURN NUMBER 
   IS total_prod NUMBER;
   BEGIN 
      SELECT COUNT(ID_PROD) INTO total_prod 
      FROM PRODUTO;
      RETURN(total_prod); 
    END;
    
 -- Utilizando chamada da função via select
 select 'TOTAL PROD: ', func_get_total_produtos from DUAL;
 
 -- Função com 1 parametro de IN Entrada para poder buscar, contar e retornar a qts produtos existe para o código passado
 -- E 1 parâmetro OUT que vai receber o nome/descrição do tipo informado
 CREATE OR REPLACE FUNCTION func_get_total_prod_tipo (p_id_tp_prod IN NUMBER, p_nm_tipo OUT VARCHAR2)
RETURN NUMBER IS
    tot_prod_tip NUMBER;
BEGIN
    select count(id_prod) into tot_prod_tip from produto
    inner join tipo_produto on (tp_prod = id_tp_prod)
    where
    id_tp_prod = p_id_tp_prod;
    select nm_tipo into p_nm_tipo from tipo_produto where id_tp_prod = p_id_tp_prod;
    return tot_prod_tip;
END;

--Testando a Função
SET SERVEROUTPUT ON
DECLARE
    retorno_nome VARCHAR2(50);
   BEGIN
   DBMS_OUTPUT.PUT_LINE('Existe ' || func_get_total_prod_tipo(1, retorno_nome) || ' Produtos Cadastrados para o Tipo : ' || retorno_nome);
   END;

-- Criado Objeto VIEW
CREATE OR REPLACE VIEW view_produtos AS
select
a.id_prod, a.nm_prod, a.dt_cad_prod, b.id_tp_prod, b.nm_tipo
from produto a
inner join tipo_produto b ON (a.tp_prod = b.id_tp_prod);

-- Selecionando Visualização
select * from view_produtos;

-- Criado um VIEW MATERIALIZED com o parametro BUILD IMMEDIATE, Atualização Completa e conforme a tabela associada a visualização sofrer alteração e commit
-- Ela é atualizada automaticamente
CREATE MATERIALIZED VIEW view_produtos_IMMEDIATE
BUILD IMMEDIATE
REFRESH COMPLETE
ON COMMIT
AS
select
a.id_prod, a.nm_prod, a.dt_cad_prod, b.id_tp_prod, b.nm_tipo
from produto a
inner join tipo_produto b ON (a.tp_prod = b.id_tp_prod);

--Adicionado um registro e aplicado commit e consultando a view materialized
EXECUTE proc_add_produto('AÇUCAR', 1);
COMMIT;
select * from view_produtos_IMMEDIATE;

--Criado view MATERIALIZED com parametro BUILD DEFERRED - atualizada manualmente na primeira requisição solicitada, REFRESH FORCE - uma atualização
-- Rápida é executado, caso não uma completa é aplicada. DEMAND é iniciada manualmente ou por agendamento!
CREATE MATERIALIZED VIEW view_produtos_DEFERRED
BUILD DEFERRED
REFRESH FORCE
ON DEMAND
AS
select
a.id_prod, a.nm_prod, a.dt_cad_prod, b.id_tp_prod, b.nm_tipo
from produto a
inner join tipo_produto b ON (a.tp_prod = b.id_tp_prod);

-- Os dados irão aparecer na VIEW MATERIALIZED só após executar o REFRESH
EXECUTE DBMS_MVIEW.REFRESH('view_produtos_DEFERRED');

